# BFSS - Reactive Synthesis 

## Preliminaries
* The benchmarks from [SYNTCOMP](https://github.com/SYNTCOMP/benchmarks/tree/master), we use the [TLSF format](https://arxiv.org/pdf/1604.02284.pdf).
* The benchmarks are converted to the `LTL3BA` (a format of LTL formulas) via [SYFCO](https://github.com/reactive-systems/syfco).
* The platform for LTL and Ï‰-automata manipulation is [Spot](https://spot.lrde.epita.fr/).

## Research: Dependent variables in benchmarks
* For each AP in the benchmark, we check if it's dependent on all other variables.
  * If variables are dependent on a subset then they depend on the set itself.
* For each benchmark we limit the execution time to 40 minutes.

### Metrics
- [x] Can spot construct the automaton of the benchmark? If yes, how long it took?
- [x] What are the dependent variables and independent variables? 
- [x] Which variables was checked?
- [x] How long it took for each variable to check if it's dependent.
- [x] Total duration of the process
- [x] Was the process finished on time, or it had a timeout? In case of timeout, at what variable checking was stopped.

### Tool: Find Dependencies
The tool to find dependencies in a LTL formula is [find_dependencies](src/find_dependencies.cpp). The usage is:
```
find_dependencies [LTL_FORMULA] [INPUT_VARS] [OUTPUT_VARS]
```
Where `[LTL_FORMULA]` is `LTL3BA`,  the variables `[INPUT_VARS] [OUTPUT_VARS]` are comma-seperated.
The flag `--verbose` can be attached to follow the process in real-time.

#### Example

`find_dependencies "G(i_1 <-> (o_1)) & G(o_2)" "i_1" "o_1,o_2"`

### How is it work?
1. Build automata of the given LTL formula.
2. For each variable `x` in LTL formula $\varphi$:
   - Check if `x` is dependent of the rest of variables.
   - Check dependency if the LTL formula is empty: $\varphi'(X, Y, X', Y')=\varphi(X, Y)\wedge \varphi(X', Y')\wedge ((Y=Y')U(Y=Y' \wedge X \neq X'))$

#### Notes
* This tool has no timeout.
* When the process gets the `SIGHUP`, it prints the metrics that was gather until the signal. 

#### Build:
* The source code of this code is in the folder [./src](src/).
* The build is done by CMake `cmake .`.
* If spot is built to a non-stand path, the path cant be attached with the flag `-DSPOT_PREFIX`. For example: `cmake . -DSPOT_PREFIX=~/spot-build` 

### Tool: Generate Benchmark File
The tool, implemented in [generate_benchmark_files.py](./tools/generate_benchmarks_file.py), generates a CSV file of benchmarks with the following columns:

* `benchmark` - the name of the benchmark
* `formula` - the formula of the benchmark
* `input_vars` - the input variables of the benchmark
* `output_vars` - the output variables of the benchmark

The tool basically does the following:
1. Find all the benchmarks with type of `.tlsf` in the folder [benchmarks](benchmark).
2. For each tlsf file, it extracts its formula, input and output variables via [syfco](syfco).
3. It writes the results to a CSV file.

### Tool: Search Dependencies in Benchmarks
The tool, implemented in [search_dependencies.py](./tools/search_dependencies_in_benchmark.py)
apply the tool [find_dependencies](src/find_dependencies.cpp) on all the benchmarks in the CSV file generated by [generate_benchmark_files.py](./tools/generate_benchmarks_file.py).

The tool basically does the following:
1. With multiprocessing, it runs `find_dependecies` in parallel on all the benchmarks.
2. It writes the results to `outputs/` folder with the format `<benchmark_name>.out`.
